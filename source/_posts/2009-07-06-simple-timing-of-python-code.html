---
layout: post
title: "Simple timing of Python code"
date: 2009-07-06
comments: false
---

<div class='post'>
Often when I am writing in Python, I find that I want to see how long a particular function call or set of statements are taking to execute.  Let's say I have the following code that gets executed frequently:<br /><pre><br />for i in range(10000000):<br />   x = 934.12 ** 32.61 * i / 453.12 ** 0.23<br /></pre><br />and I want to know how long it takes to execute to see if it is slowing down my app and should be optimized. Previously I would surround it as such:<br /><pre><br />import time; x = time.time()<br />for i in range(10000000):<br />   x = 934.12 ** 32.61 * i / 453.12 ** 0.23<br />print time.time() - x<br /></pre><br />This will print out the duration in seconds of that code segment, but is more work and typing than I want, and more cleaning up later. I realized that the new "with" statement in Python could probably help me out. Let's create a little timer class that cooperates with it:<br /><pre><br />class Timer():<br />   def __enter__(self): self.start = time.time()<br />   def __exit__(self, *args): print time.time() - self.start<br /></pre><br />Now all we have to do is:<br /><pre><br />with Timer():<br />   for i in range(1000000):<br />       x = 934.12 ** 32.61 * i / 453.12 ** 0.23<br /></pre><br />You can also try:<br /><pre><br />with Timer():<br />   time.sleep(1.5)<br /></pre><br /><br />For these, 0.28738 and 1.50169 are what I get, respectively. While something like this couldn't really replace application-wide profiling via <a href="http://docs.python.org/library/profile.html">a module like cProfile</a>, it can be an extremely useful and quick way to see if your prototype is scalable or not. I usually end up having a debug.py or helpers.py file in my larger projects with little tools like this, and I'll probably end up adding this one as well.<br /><br />Let me know if you are doing something similar, or if I've reinvented something that already exists. I'd also love to hear from people profiling their python code and what techniques they are using, as I am just starting to learn about it.</div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>flimm</div>
<div class='content'>
Got here after reading wxbanker&#39;s source code. You&#39;re right, it does look handy.</div>
</div>
<div class='comment'>
<div class='author'>mgedmin</div>
<div class='content'>
Using the with statement for this is a brilliant idea!<br /><br />Check out <a href="http://pypi.python.org/pypi/profilehooks" rel="nofollow">profilehooks</a> on PyPI for something like this at function level, implemented using decorators.  I wonder how difficult it would be to have the same object (or function) act both as a decorator and as a context manager.<br /><br />Timeit is a great module, but it serves a different purpose: very accurate microbenchmarks.  Sometimes you just need to know whether a for loop takes 1 or 20 seconds; repeating that for loop 1000 times to get its accurate speed up to the nearest microsecond is overkill.  Plus, timeit&#39;s API is cumbersome and inconvenient, or at least I can never remember offhand how to use it, which is the same thing in my book.</div>
</div>
<div class='comment'>
<div class='author'>Paddy3118</div>
<div class='content'>
... The timeit module documentation states that it stops you repeating some common errors when doing this kind of task.</div>
</div>
<div class='comment'>
<div class='author'>Michael</div>
<div class='content'>
Thanks liw.fi for pointing that out, I wasn&#39;t aware of it! However while convenient, I don&#39;t think it is as trivially injectable into existing code paths. It looks great for testing a function or one-liner, but not for a random segment of code that might be a part of a large function / sequence.</div>
</div>
<div class='comment'>
<div class='author'>liw.fi</div>
<div class='content'>
See also the timeit module in the standard library.</div>
</div>
</div>
